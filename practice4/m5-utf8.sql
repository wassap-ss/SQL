--=============== МОДУЛЬ 5. РАБОТА С POSTGRESQL =======================================
--= ПОМНИТЕ, ЧТО НЕОБХОДИМО УСТАНОВИТЬ ВЕРНОЕ СОЕДИНЕНИЕ И ВЫБРАТЬ СХЕМУ PUBLIC===========
SET search_path TO public;

--======== ОСНОВНАЯ ЧАСТЬ ==============

--ЗАДАНИЕ №1
--Сделайте запрос к таблице payment и с помощью оконных функций добавьте вычисляемые колонки согласно условиям:
--1.1 Пронумеруйте все платежи от 1 до N по дате платежа
--1.2 Пронумеруйте платежи для каждого покупателя, сортировка платежей должна быть по дате платежа
--1.3 Посчитайте нарастающим итогом сумму всех платежей для каждого покупателя, сортировка должна быть 
--сперва по дате платежа, а затем по размеру платежа от наименьшей к большей
--1.4 Пронумеруйте платежи для каждого покупателя по размеру платежа от наибольшего к меньшему так, 
--чтобы платежи с одинаковым значением имели одинаковое значение номера.
--В результирующей таблице должны быть следующие столбцы: Идентификатор платежа, дата платежа, 
--идентификатор пользователя, размер платежа, 4 столбца с результатами оконных функций.


SELECT 
    payment_id,
    payment_date,
    customer_id,
    amount,
    ROW_NUMBER() OVER (ORDER BY payment_date) as num_global,
    ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY payment_date) as num_customer,
    SUM(amount) OVER (PARTITION BY customer_id ORDER BY payment_date, amount) as cumulative_total,
    DENSE_RANK() OVER (PARTITION BY customer_id ORDER BY amount DESC) as amount_rank
    FROM payment
ORDER BY customer_id, payment_date


--ЗАДАНИЕ №2
--С помощью оконной функции выведите для каждого покупателя стоимость платежа и стоимость 
--платежа из предыдущей строки со значением по умолчанию 0.0 с сортировкой по дате платежа.
--В результирующей таблице должны быть следующие столбцы: Идентификатор платежа, дата платежа, 
--идентификатор пользователя, текущий размер платежа, размер платежа из предыдущей строки.


SELECT 
    payment_id,
    payment_date,
     customer_id,
    amount as current_amount,
    COALESCE(LAG(amount) OVER (PARTITION BY customer_id ORDER BY payment_date), 0.0) as previous_amount
FROM 
    payment
ORDER BY 
    customer_id, payment_date


--ЗАДАНИЕ №3
--С помощью оконной функции определите, на сколько каждый следующий платеж покупателя больше или меньше текущего.
--В результирующей таблице должны быть следующие столбцы: Идентификатор платежа, дата платежа, идентификатор пользователя, 
--текущий размер платежа, следующий размер платежа, разница между текущим и следующим платежами.


SELECT 
    payment_id,
    payment_date,
    customer_id,
    amount as current_amount,
    LEAD(amount) OVER (PARTITION BY customer_id ORDER BY payment_date) as next_amount,
    amount - LEAD(amount) OVER (PARTITION BY customer_id ORDER BY payment_date) as diff
FROM 
    payment
ORDER BY 
    customer_id, payment_date

/* столбец next_amount со значением null означает отсвутсввие платежа и как следсвтие дифф тоже нал */

--ЗАДАНИЕ №4
--С помощью оконной функции для каждого покупателя выведите данные о его последней оплате аренды.
--В результирующей таблице должны быть следующие столбцы: Все столбцы из таблицы с платежами.

WITH last_payment as (
    SELECT *,
        ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY payment_date DESC) as row_numb
    FROM 
        payment
)
SELECT 
    payment_id,
    customer_id,
    staff_id,
    rental_id,
    amount,
    payment_date
FROM 
    last_payment
WHERE 
    row_numb = 1
ORDER BY 
    customer_id


--======== ДОПОЛНИТЕЛЬНАЯ ЧАСТЬ ==============


пожалуй я возьму отдельно курс по sql, мне кажется в курсе на систем анала всетаки мне недостаточно тайминга 
и материала выделенного на эту программу





--ЗАДАНИЕ №1
--С помощью оконной функции выведите для каждого сотрудника сумму продаж за август 2005 года 
--с нарастающим итогом по каждому сотруднику и по каждой дате продажи (без учёта времени) 
--с сортировкой по дате.
--В результирующей таблице должны быть следующие столбцы: Фамилия и имя сотрудника в виде 
--одного значения, сумма продаж на каждый день, накопительный итог.




--ЗАДАНИЕ №2
--20 августа 2005 года в магазинах проходила акция: покупатель каждого сотого платежа получал
--дополнительную скидку на следующую аренду. С помощью оконной функции выведите всех покупателей,
--которые в день проведения акции получили скидку
--В результирующей таблице должны быть следующие столбцы: Идентификатор пользователя, 
--фамилия и имя пользователя в виде одного значения.



--ЗАДАНИЕ №3
--Для каждой страны определите и выведите одним SQL-запросом покупателей, которые попадают под условия:
-- 1. покупатель, арендовавший наибольшее количество фильмов
-- 2. покупатель, арендовавший фильмов на самую большую сумму
-- 3. покупатель, который последним арендовал фильм
--В результирующей таблице должны быть следующие столбцы: Название страны, фамилия и имя пользователя в 
--виде одного значения лучшего по количеству, фамилия и имя пользователя в виде одного значения лучшего 
--по сумме платежей, фамилия и имя пользователя в виде одного значения последним арендовавшим фильм.
--Есть два варианта решения: получать одного случайного, если в топ 1 попадает несколько пользователей, 
--выводить всех пользователей, попавших в топ 1. Выбор варианта остается за вами.






